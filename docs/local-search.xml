<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Jointjs 使用总结</title>
    <link href="/2021/05/24/use_jointjs/"/>
    <url>/2021/05/24/use_jointjs/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/atri.png" srcset="/img/loading.gif" alt=""></p><!-- TOC --><ul><li><a href="#1-jointjs-使用总结">1. Jointjs 使用总结</a><ul><li><a href="#11-版本">1.1. 版本</a></li><li><a href="#12-初始化相关">1.2. 初始化相关</a><ul><li><a href="#121-代码示例">1.2.1. 代码示例</a></li></ul></li><li><a href="#13-图形元素">1.3. 图形元素</a><ul><li><a href="#131-绑定元素点击事件">1.3.1. 绑定元素点击事件</a></li><li><a href="#132-绑定连线的操作工具">1.3.2. 绑定连线的操作工具</a></li><li><a href="#133-shapesstandard-标准插件">1.3.3. shapes.standard 标准插件</a></li><li><a href="#134-连线">1.3.4. 连线</a></li></ul></li><li><a href="#14-通用方法">1.4. 通用方法</a><ul><li><a href="#141-画布导入和导出">1.4.1. 画布导入和导出</a></li><li><a href="#142-常用方法">1.4.2. 常用方法</a></li></ul></li><li><a href="#15-整体代码示例">1.5. 整体代码示例</a></li></ul></li></ul><!-- /TOC --><h1 id="1-Jointjs-使用总结"><a href="#1-Jointjs-使用总结" class="headerlink" title="1. Jointjs 使用总结"></a>1. Jointjs 使用总结</h1><p>Jointjs 是一个使用 svg 绘制流程图、拓扑关系图的 JS 库，比起 G6 引擎来说，jointjs 的接口使用更直观，最终呈现效果也比较理想，特别是 Link 类型连线的自带工具非常好用，完美契合开发需求。但是这个库比较冷门，中文资料不多，而且多数都是踩坑记录，事实上我实际用起来也是踩了无数的坑，心累</p><h2 id="1-1-版本"><a href="#1-1-版本" class="headerlink" title="1.1. 版本"></a>1.1. 版本</h2><p>目前官方最新版本为 3.3.1，项目里的 webpack 版本比较老，直接使用 npm 安装 3.3.1 会出现打包失败的情况，推测是因为最新版本引用的某个库代码兼容性不够导致的，所以以下内容均基于 3.1.0 版本。</p><blockquote><p>文档相关链接</p></blockquote><p>官方文档，版本不能切换时直接修改链接地址的版本 <a href="https://resources.jointjs.com/docs/jointjs/v3.3/joint.html" target="_blank" rel="noopener">https://resources.jointjs.com/docs/jointjs/v3.3/joint.html</a></p><p>旧版文档翻译参考 <a href="https://segmentfault.com/a/1190000004579894" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004579894</a></p><p>事件类型参考 <a href="https://blog.csdn.net/qq_39324050/article/details/109530753" target="_blank" rel="noopener">https://blog.csdn.net/qq_39324050/article/details/109530753</a></p><p>svg 文档 <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/tspan" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/SVG/Element/tspan</a></p><h2 id="1-2-初始化相关"><a href="#1-2-初始化相关" class="headerlink" title="1.2. 初始化相关"></a>1.2. 初始化相关</h2><ol><li><p>使用 import 方式引入</p><ul><li><code>npm i jointjs -S</code>，自带 jQuery、backbone、lodash，如果使用 script 标签引入，需要手动引入这些依赖</li><li><code>import * as joint from &#39;jointjs&#39;</code> 整体引入（常用）</li><li><code>import { dia } from &#39;jointjs/src/core.mjs&#39;</code> 按需引入</li></ul><p>项目里只用了 import 方式引入，所以也导致踩了一系列坑，建议尝试用 script 全局引入，坑应该少一点（x</p></li><li><p>初始化画布</p></li></ol><blockquote><p>坑注意：import 方式引入的时候，joint 全局变量是没有全局挂载的，所以必须手动传入 cellNamespace 参数，不然报错</p></blockquote><p>ES6 引入时命名空间报错问题参考 <a href="https://stackoverflow.com/questions/57428402/getting-error-dia-elementview-markup-required-from-graph-fromjsonjson" target="_blank" rel="noopener">https://stackoverflow.com/questions/57428402/getting-error-dia-elementview-markup-required-from-graph-fromjsonjson</a></p><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joint <span class="hljs-keyword">from</span> <span class="hljs-string">"jointjs"</span>;<span class="hljs-comment">// 初始化画布模型，使用 ES6 引入 jointjs 时，joint 全局变量未注册，必须传入 cellNamespace 参数</span><span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> joint.dia.Graph(&#123;&#125;, &#123; <span class="hljs-attr">cellNamespace</span>: joint.shapes &#125;);<span class="hljs-comment">// 初始化画布视图</span><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"paper"</span>);<span class="hljs-keyword">const</span> height = element.clientHeight;<span class="hljs-keyword">const</span> width = element.clientWidth;<span class="hljs-keyword">const</span> paper = <span class="hljs-keyword">new</span> joint.dia.Paper(&#123;  <span class="hljs-comment">// 挂载的 dom 元素</span>  el: element,  <span class="hljs-comment">// 关联声明的 graph</span>  model: graph,  <span class="hljs-comment">// 画布大小，初始化之后还可以动态调整，项目里没试过，自行查资料</span>  width,  height,  defaultAnchor: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"perpendicular"</span> &#125;,  gridSize: <span class="hljs-number">5</span>, <span class="hljs-comment">// 画布上元素拖动时步进的为5像素，默认1</span>  drawGrid: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 显示步进点，方便对齐，3.1.0 版本貌似不起作用？</span>  <span class="hljs-comment">// snapLinks: &#123;</span>  <span class="hljs-comment">//   radius: 5, // 距离元素连接点 5 像素时自动连接上</span>  <span class="hljs-comment">// &#125;,</span>  snapLinks: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 坑注意，3.1.0 版本设置像素值时会以元素中心点来计算范围，像上面设置为 5，范围就会特别小</span>  interactive: &#123;    <span class="hljs-comment">// 禁用元素拖拽、连线标签拖拽</span>    elementMove: <span class="hljs-literal">true</span>,    labelMove: <span class="hljs-literal">true</span>,    linkMove: <span class="hljs-literal">true</span>,    arrowheadMove: <span class="hljs-literal">true</span>,  &#125;,  cellViewNamespace: joint.shapes, <span class="hljs-comment">// 注意必须同步传入 cellViewNamespace 参数</span>  <span class="hljs-comment">// linkConnectionPoint: joint.util.shapePerimeterConnectionPoint, // 链接将尝试在连接形状的周长上找到最佳的连接点，而不仅仅是在边界框上（3.1.0 貌似不起作用）</span>&#125;);</code></pre><ol><li><p>清除画布所有元素</p><ul><li><code>graph.clear()</code> 清除元素</li><li><code>paper.remove()</code> 这两个没具体研究，但是 paper.remove 好像同时会清理绑定的监听事件，一般我会同时调用这两个方法来清空画布</li></ul></li><li><p>画布缩放平移</p></li></ol><p>jointjs 底层是用 svg 实现的，本身没有自带缩放平移的方法，需要手动绑定</p><p>平移参考 <a href="https://stackoverflow.com/questions/28431384/how-to-make-a-paper-draggable" target="_blank" rel="noopener">https://stackoverflow.com/questions/28431384/how-to-make-a-paper-draggable</a></p><p>缩放参考找不到了</p><h3 id="1-2-1-代码示例"><a href="#1-2-1-代码示例" class="headerlink" title="1.2.1. 代码示例"></a>1.2.1. 代码示例</h3><blockquote><p>多个动作需要绑定相同事件时，用空格分割，栗子：<code>&#39;blank:pointerup blank:mouseout&#39;</code></p></blockquote><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 绑定鼠标滚轮缩放事件</span><span class="hljs-comment"> */</span>bindMouseWheel() &#123;  <span class="hljs-comment">// 注意两个事件的回调参数不一致</span>  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:mousewheel'</span>, (e, x, y, delta) =&gt; <span class="hljs-keyword">this</span>.handleCellMouseWheel(e, x, y, delta));  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'element:mousewheel'</span>, (cellView, e, x, y, delta) =&gt; <span class="hljs-keyword">this</span>.handleCellMouseWheel(e, x, y, delta));&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 复制代码，抄就行了不解释</span><span class="hljs-comment"> */</span>handleCellMouseWheel(e, x, y, delta) &#123;  e.preventDefault();  <span class="hljs-keyword">const</span> oldScale = <span class="hljs-keyword">this</span>.paper.scale().sx;  <span class="hljs-keyword">const</span> newScale = oldScale + delta * <span class="hljs-number">0.1</span>;  <span class="hljs-keyword">this</span>.scaleToPoint(newScale, x, y);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 复制代码</span><span class="hljs-comment"> */</span>scaleToPoint(nextScale, x, y) &#123;  <span class="hljs-keyword">if</span> (nextScale &gt;= MIN_SCALE &amp;&amp; nextScale &lt;= MAX_SCALE) &#123;    <span class="hljs-keyword">const</span> currentScale = <span class="hljs-keyword">this</span>.paper.scale().sx;    <span class="hljs-keyword">const</span> beta = currentScale / nextScale;    <span class="hljs-keyword">const</span> ax = x - x * beta;    <span class="hljs-keyword">const</span> ay = y - y * beta;    <span class="hljs-keyword">const</span> translate = <span class="hljs-keyword">this</span>.paper.translate();    <span class="hljs-keyword">const</span> nextTx = translate.tx - ax * nextScale;    <span class="hljs-keyword">const</span> nextTy = translate.ty - ay * nextScale;    <span class="hljs-keyword">this</span>.paper.translate(nextTx, nextTy);    <span class="hljs-keyword">const</span> ctm = <span class="hljs-keyword">this</span>.paper.matrix();    ctm.a = nextScale;    ctm.d = nextScale;    <span class="hljs-keyword">this</span>.paper.matrix(ctm);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 绑定画布平移事件，mousedown 记录当前画布位置坐标（并计算缩放比），mouseup 清除当前画布位置坐标</span><span class="hljs-comment"> * 画布本身未定义鼠标移动相关事件，所以利用 dom 监听 mousemove 事件，将鼠标移动参数转换为画布移动</span><span class="hljs-comment"> * 组件卸载时要调用 destroy 事件清除事件监听</span><span class="hljs-comment"> */</span>bindDragPaper() &#123;  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:pointerdown'</span>, (e, x, y) =&gt; &#123;    <span class="hljs-keyword">const</span> scale = <span class="hljs-keyword">this</span>.paper.scale();    <span class="hljs-keyword">this</span>.dragPosition = [x * scale.sx, y * scale.sy];    <span class="hljs-keyword">this</span>.element.removeEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc);    <span class="hljs-keyword">this</span>.element.addEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc.bind(<span class="hljs-keyword">this</span>));  &#125;);  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:pointerup blank:mouseout'</span>, (e) =&gt; &#123;    <span class="hljs-keyword">this</span>.dragPosition = [];    <span class="hljs-keyword">this</span>.element.removeEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc);  &#125;);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 转换画布平移坐标</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>e mousemove 事件回调对象</span><span class="hljs-comment"> */</span>dragFunc(e) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dragPosition.length) &#123;    <span class="hljs-keyword">this</span>.paper.translate(e.offsetX - <span class="hljs-keyword">this</span>.dragPosition[<span class="hljs-number">0</span>], e.offsetY - <span class="hljs-keyword">this</span>.dragPosition[<span class="hljs-number">1</span>]);  &#125;&#125;</code></pre><p>附录</p><ol><li><p>禁止标签拖动，参考 <a href="https://stackoverflow.com/questions/45382941/in-jointjs-how-to-prevent-element-with-ports-from-being-moved-but-still-allow" target="_blank" rel="noopener">https://stackoverflow.com/questions/45382941/in-jointjs-how-to-prevent-element-with-ports-from-being-moved-but-still-allow</a></p></li><li><p>自定义元素引用报错，参考 <a href="https://github.com/clientIO/joint/issues/1281" target="_blank" rel="noopener">https://github.com/clientIO/joint/issues/1281</a></p></li></ol><h2 id="1-3-图形元素"><a href="#1-3-图形元素" class="headerlink" title="1.3. 图形元素"></a>1.3. 图形元素</h2><h3 id="1-3-1-绑定元素点击事件"><a href="#1-3-1-绑定元素点击事件" class="headerlink" title="1.3.1. 绑定元素点击事件"></a>1.3.1. 绑定元素点击事件</h3><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 绑定元素点击事件</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;function&#125;</span> </span>callback 回调函数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;boolean&#125;</span> </span>highlight 点击元素是否高亮</span><span class="hljs-comment"> */</span>bindClick(callback, highlight) &#123;  <span class="hljs-keyword">const</span> bindFunc = <span class="hljs-function">(<span class="hljs-params">cellView, evt, x, y</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> cells = <span class="hljs-keyword">this</span>.graph.getCells();    cells.forEach(<span class="hljs-function">(<span class="hljs-params">cell</span>) =&gt;</span> &#123;      <span class="hljs-comment">// 取消其他元素高亮</span>      <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">this</span>.paper.findViewByModel(cell);      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> view.unhighlight === <span class="hljs-string">'function'</span>) &#123;        view.unhighlight();      &#125;    &#125;);    <span class="hljs-comment">// 高亮当前点击的元素</span>    <span class="hljs-keyword">if</span> (cellView &amp;&amp; highlight) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cellView.highlight === <span class="hljs-string">'function'</span>) &#123;        cellView.highlight();      &#125;    &#125;    <span class="hljs-comment">// 点击事件回调</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) &#123;      callback(cellView);    &#125;  &#125;;  <span class="hljs-comment">// 绑定元素点击事件，坑注意：绑定 pointerclick 会有无法触发的 bug，所以退而监听 pointerup</span>  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'cell:pointerup link:pointerup'</span>, (cellView, evt, x, y) =&gt; bindFunc(cellView, evt, x, y));  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:pointerup'</span>, (evt, x, y) =&gt; bindFunc(<span class="hljs-literal">null</span>, evt, x, y));&#125;</code></pre><h3 id="1-3-2-绑定连线的操作工具"><a href="#1-3-2-绑定连线的操作工具" class="headerlink" title="1.3.2. 绑定连线的操作工具"></a>1.3.2. 绑定连线的操作工具</h3><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@description </span>绑定连线相关属性，参考官方手册</span><span class="hljs-comment"> */</span>bindLinkEvent() &#123;  <span class="hljs-comment">// 绑定连线的操作</span>  <span class="hljs-keyword">const</span> verticesTool = <span class="hljs-keyword">new</span> joint.linkTools.Vertices();  <span class="hljs-keyword">const</span> segmentsTool = <span class="hljs-keyword">new</span> joint.linkTools.Segments();  <span class="hljs-keyword">const</span> sourceArrowheadTool = <span class="hljs-keyword">new</span> joint.linkTools.SourceArrowhead();  <span class="hljs-keyword">const</span> targetArrowheadTool = <span class="hljs-keyword">new</span> joint.linkTools.TargetArrowhead();  <span class="hljs-keyword">const</span> sourceAnchorTool = <span class="hljs-keyword">new</span> joint.linkTools.SourceAnchor();  <span class="hljs-keyword">const</span> targetAnchorTool = <span class="hljs-keyword">new</span> joint.linkTools.TargetAnchor();  <span class="hljs-keyword">const</span> boundaryTool = <span class="hljs-keyword">new</span> joint.linkTools.Boundary();  <span class="hljs-keyword">const</span> removeButton = <span class="hljs-keyword">new</span> joint.linkTools.Remove();  <span class="hljs-keyword">const</span> toolsView = <span class="hljs-keyword">new</span> joint.dia.ToolsView(&#123;    tools: [      verticesTool,      segmentsTool,      sourceArrowheadTool,      targetArrowheadTool,      sourceAnchorTool,      targetAnchorTool,      boundaryTool,      removeButton,    ],  &#125;);  <span class="hljs-comment">// 鼠标移入时显示工具，移除时隐藏工具</span>  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'link:mouseenter'</span>, (linkView) =&gt; &#123;    linkView.addTools(toolsView);    linkView.showTools(toolsView);  &#125;);  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'link:mouseleave'</span>, (linkView) =&gt; &#123;    <span class="hljs-comment">// 坑注意：3.1.0 版本不能用 addTools 和 removeTools 搭配，不然工具会 bug，显示不全</span>    linkView.hideTools();  &#125;);&#125;</code></pre><h3 id="1-3-3-shapes-standard-标准插件"><a href="#1-3-3-shapes-standard-标准插件" class="headerlink" title="1.3.3. shapes.standard 标准插件"></a>1.3.3. shapes.standard 标准插件</h3><p>具体各个插件的用法可以参考官方文档</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> standard = joint.shapes.standard;<span class="hljs-keyword">const</span> rectangle = <span class="hljs-keyword">new</span> standard.Rectangle();<span class="hljs-keyword">const</span> circle = <span class="hljs-keyword">new</span> standard.Circle();<span class="hljs-keyword">const</span> ellipse = <span class="hljs-keyword">new</span> standard.Ellipse();<span class="hljs-keyword">const</span> path = <span class="hljs-keyword">new</span> standard.Path();<span class="hljs-keyword">const</span> polygon = <span class="hljs-keyword">new</span> standard.Polygon();<span class="hljs-keyword">const</span> polyline = <span class="hljs-keyword">new</span> standard.Polyline();<span class="hljs-keyword">const</span> cylinder = <span class="hljs-keyword">new</span> standard.Cylinder();<span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> standard.Image();<span class="hljs-keyword">const</span> borderedImage = <span class="hljs-keyword">new</span> standard.BorderedImage();<span class="hljs-keyword">const</span> embeddedImage = <span class="hljs-keyword">new</span> standard.EmbeddedImage();<span class="hljs-keyword">const</span> headeredRectangle = <span class="hljs-keyword">new</span> standard.HeaderedRectangle();<span class="hljs-keyword">const</span> textBlock = <span class="hljs-keyword">new</span> standard.TextBlock();<span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> standard.Link();<span class="hljs-keyword">const</span> doubleLink = <span class="hljs-keyword">new</span> standard.DoubleLink();<span class="hljs-keyword">const</span> shadowLink = <span class="hljs-keyword">new</span> standard.ShadowLink();</code></pre><blockquote><p>使用方式以 circle 为例</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>x 坐标</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">y</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span> </span>元素在画布上的唯一 ID</span><span class="hljs-comment"> */</span>addCircle(x = <span class="hljs-number">10</span>, y = <span class="hljs-number">10</span>) &#123;  <span class="hljs-keyword">const</span> circle = <span class="hljs-keyword">new</span> joint.shapes.standard.Circle();  circle.resize(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>); <span class="hljs-comment">// 元素大小</span>  circle.position(x, y); <span class="hljs-comment">// 元素位置</span>  circle.attr(<span class="hljs-string">'root/title'</span>, <span class="hljs-string">'测试元素'</span>); <span class="hljs-comment">// 设置 dom 的 title 属性</span>  circle.attr(<span class="hljs-string">'label/text'</span>, <span class="hljs-string">'hello\nworld'</span>); <span class="hljs-comment">// 文字，注意 svg 控制换行非常麻烦，用 \n 能够解决换行的问题</span>  circle.attr(<span class="hljs-string">'label/fontSize'</span>, <span class="hljs-string">'25'</span>); <span class="hljs-comment">// 文字大小</span>  circle.attr(<span class="hljs-string">'body/fill'</span>, <span class="hljs-string">'#f79204'</span>); <span class="hljs-comment">// 背景颜色</span>  circle.attr(<span class="hljs-string">'body/stroke'</span>, <span class="hljs-string">'#f79204'</span>); <span class="hljs-comment">// 边框颜色</span>  circle.attr(<span class="hljs-string">'label/fill'</span>, <span class="hljs-string">'#fff'</span>); <span class="hljs-comment">// 文字颜色</span>  <span class="hljs-keyword">this</span>.graph.addCell(circle); <span class="hljs-comment">// 单个添加</span>  <span class="hljs-comment">// this.graph.addCells([circle]); // 也可以批量添加</span>  <span class="hljs-keyword">if</span> (id) &#123;    <span class="hljs-comment">// 回显画布时，也可以覆盖元素自身生成的 ID</span>    circle.prop([<span class="hljs-string">'id'</span>], id);  &#125;  <span class="hljs-keyword">return</span> circle.id;  <span class="hljs-comment">// joint.util.breakText('this is quite a long text', &#123; width: 50 &#125;) 自动根据宽度换行，3.1.0 貌似不起作用</span>&#125;</code></pre><blockquote><p>使用方式分析</p></blockquote><ol><li>画布添加元素有两种方法，批量添加和单个添加</li><li>元素的属性设置可以使用两种方法，一般推荐使用 <code>item.attr()</code> 方法操作相应属性，但是有些上层属性是不属于 attr 方法的，比如连线的相关属性，此时可以尝试使用 <code>item.prop([...], ...)</code> 操作属性，其中第一个数组参数代表属性的层级，与 <code>attr</code> 方法的斜杠划分意义相同</li></ol><h3 id="1-3-4-连线"><a href="#1-3-4-连线" class="headerlink" title="1.3.4. 连线"></a>1.3.4. 连线</h3><p>连线单独列出来，因为连线的操作比较复杂，jointjs 本身是支持元素之间直接新建连接，没研究透，不会用</p><p>注意连线的标签属性在上层对象里，需要使用 <code>item.prop()</code> 方法进行控制</p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加连接线</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>x 初始坐标</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>y 初始坐标</span><span class="hljs-comment"> */</span>addLink(x = <span class="hljs-number">50</span>, y = <span class="hljs-number">50</span>) &#123;  <span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> joint.shapes.standard.Link();  link.source(&#123; x, y &#125;); <span class="hljs-comment">// 起点，可以传元素字符串 ID</span>  <span class="hljs-comment">// link.source(id);</span>  link.target(&#123; <span class="hljs-attr">x</span>: x + <span class="hljs-number">80</span>, y &#125;); <span class="hljs-comment">// 终点</span>  link.labels([    &#123;      attrs: &#123;        text: &#123;          text: <span class="hljs-string">''</span>, <span class="hljs-comment">// 标签文字</span>        &#125;,      &#125;,    &#125;,  ]);  link.attr(<span class="hljs-string">'line/stroke'</span>, <span class="hljs-string">'#2f76ff'</span>); <span class="hljs-comment">// 线条颜色</span>  link.prop([<span class="hljs-string">'doubleLinkTools'</span>], <span class="hljs-string">'true'</span>); <span class="hljs-comment">// 显示双箭头</span>  link.prop([<span class="hljs-string">'labels'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'attrs'</span>, <span class="hljs-string">'rect'</span>, <span class="hljs-string">'fill'</span>], <span class="hljs-string">'rgba(0, 0, 0, 0)'</span>); <span class="hljs-comment">// 标签背景矩形的颜色</span>  <span class="hljs-keyword">this</span>.graph.addCell(link);&#125;</code></pre><h2 id="1-4-通用方法"><a href="#1-4-通用方法" class="headerlink" title="1.4. 通用方法"></a>1.4. 通用方法</h2><h3 id="1-4-1-画布导入和导出"><a href="#1-4-1-画布导入和导出" class="headerlink" title="1.4.1. 画布导入和导出"></a>1.4.1. 画布导入和导出</h3><p>jointjs 支持直接将画布导出为 json 对象，也可以将对象导入到画布上</p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 导出画布元素</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> <span class="hljs-variable">JSON</span></span></span><span class="hljs-comment"> */</span>exportGraph() &#123;  <span class="hljs-keyword">const</span> jsonData = <span class="hljs-keyword">this</span>.graph.toJSON();  <span class="hljs-keyword">return</span> jsonData;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 导入画布数据，JSON 对象，注意并非 JSON 字符串</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>jsonData JSON</span><span class="hljs-comment"> * <span class="hljs-doctag">@example <span class="hljs-type">&#123;"cells": [&#123;...&#125;</span></span>, &#123;...&#125;]&#125;</span><span class="hljs-comment"> */</span>importGraph(jsonData) &#123;  <span class="hljs-keyword">this</span>.graph.fromJSON(jsonData);&#125;</code></pre><h3 id="1-4-2-常用方法"><a href="#1-4-2-常用方法" class="headerlink" title="1.4.2. 常用方法"></a>1.4.2. 常用方法</h3><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 移除单个元素</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>cellView 元素对象，视图对象或者模型对象均可，可以使用下述 getCellByID() 方法来获取</span><span class="hljs-comment"> */</span>removeItem(cellView) &#123;  <span class="hljs-keyword">if</span> (cellView.model &amp;&amp; <span class="hljs-keyword">typeof</span> cellView.model.remove === <span class="hljs-string">'function'</span>) &#123;    cellView.model.remove();  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cellView.remove === <span class="hljs-string">'function'</span>) &#123;    cellView.remove();  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取当前画布所有元素，和导出画布好像差不多</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Array&#125;</span> </span>元素数组</span><span class="hljs-comment"> */</span>getCells() &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.graph.getCells();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用元素 ID 获取元素视图对象，可以用于操作元素属性、删除元素</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">id</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> </span>元素视图对象</span><span class="hljs-comment"> */</span>getCellByID(id) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.graph.getCell(id);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取画布当前的缩放比例和平移位置</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> <span class="hljs-type">&#123;scale, position&#125;</span></span></span><span class="hljs-comment"> */</span>getPaperScaleAndPos() &#123;  <span class="hljs-keyword">const</span> scale = <span class="hljs-keyword">this</span>.paper.scale();  <span class="hljs-keyword">const</span> position = <span class="hljs-keyword">this</span>.paper.translate();  <span class="hljs-keyword">return</span> &#123; scale, position &#125;;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 清除当前画布</span><span class="hljs-comment"> */</span>clearGraph() &#123;  <span class="hljs-keyword">this</span>.graph.clear();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 销毁当前画布，并且销毁画布所有监听事件</span><span class="hljs-comment"> */</span>destroy() &#123;  <span class="hljs-keyword">this</span>.clearGraph();  <span class="hljs-keyword">this</span>.paper.remove();  <span class="hljs-comment">// 移除画布平移绑定的 dom 事件</span>  <span class="hljs-keyword">this</span>.element.removeEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc);&#125;</code></pre><h2 id="1-5-整体代码示例"><a href="#1-5-整体代码示例" class="headerlink" title="1.5. 整体代码示例"></a>1.5. 整体代码示例</h2><p>项目需求比较简单，所以也没做彻底研究，写的类也只能基本适应简单需求，权当参考，自定义元素这部分实在没理解透，只能退而求其次使用单独添加渲染的方式来自定义元素，逻辑也就显得有点啰嗦了</p><pre><code class="hljs js"><span class="hljs-comment">/* eslint-disable class-methods-use-this */</span><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joint <span class="hljs-keyword">from</span> <span class="hljs-string">'jointjs'</span>;<span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash'</span>;<span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">'jquery'</span>;<span class="hljs-keyword">const</span> MIN_SCALE = <span class="hljs-number">0.1</span>;<span class="hljs-keyword">const</span> MAX_SCALE = <span class="hljs-number">10</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@classdesc </span>jointjs 封装</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>id 绑定的 dom ID</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;boolean&#125;</span> </span>elementMove 是否禁用元素拖拽</span><span class="hljs-comment"> * <span class="hljs-doctag">@date </span>2021-05-8</span><span class="hljs-comment"> * <span class="hljs-doctag">@author <span class="hljs-variable">zhw</span></span></span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JointJS</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@desc </span>画布模型对象</span><span class="hljs-comment">   */</span>  graph = <span class="hljs-literal">null</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@desc </span>画布视图对象</span><span class="hljs-comment">   */</span>  paper = <span class="hljs-literal">null</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@desc </span>画布渲染绑定的 dom 对象</span><span class="hljs-comment">   */</span>  element = <span class="hljs-literal">null</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@desc </span>自定义元素组</span><span class="hljs-comment">   */</span>  customElement = &#123;&#125;;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@desc </span>拖拽画布时保存画布初始位置，用于计算拖拽距离</span><span class="hljs-comment">   */</span>  dragPosition = [];  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>id 绑定的 dom ID</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;boolean&#125;</span> </span>elementMove 是否禁用元素拖拽</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">constructor</span>(id, elementMove = true) &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">this</span>.element = <span class="hljs-built_in">document</span>.getElementById(id);      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.element) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'找不到挂载点'</span>);      &#125;      <span class="hljs-keyword">this</span>.initGraph();      <span class="hljs-keyword">this</span>.initPaper(elementMove);      <span class="hljs-keyword">this</span>.initCustomElement();      <span class="hljs-keyword">this</span>.bindEvent();    &#125; <span class="hljs-keyword">catch</span> (e) &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'jointjs error:'</span>, e.message);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@protected</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>初始化画布模型，使用 ES6 引入 jointjs 时，joint 全局变量未注册，必须传入 cellNamespace 参数</span><span class="hljs-comment">   */</span>  initGraph() &#123;    <span class="hljs-keyword">this</span>.graph = <span class="hljs-keyword">new</span> joint.dia.Graph(&#123;&#125;, &#123; <span class="hljs-attr">cellNamespace</span>: joint.shapes &#125;);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@protected</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>初始化画布视图，必须传入 cellViewNamespace 参数</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;boolean&#125;</span> </span>movable 元素是否可拖拽</span><span class="hljs-comment">   */</span>  initPaper(movable) &#123;    <span class="hljs-keyword">const</span> height = <span class="hljs-keyword">this</span>.element.clientHeight;    <span class="hljs-keyword">const</span> width = <span class="hljs-keyword">this</span>.element.clientWidth;    <span class="hljs-keyword">this</span>.paper = <span class="hljs-keyword">new</span> joint.dia.Paper(&#123;      <span class="hljs-comment">// 挂载的 dom 元素</span>      el: <span class="hljs-keyword">this</span>.element,      <span class="hljs-comment">// 关联声明的 graph</span>      model: <span class="hljs-keyword">this</span>.graph,      width,      height,      defaultAnchor: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'perpendicular'</span> &#125;,      gridSize: <span class="hljs-number">5</span>, <span class="hljs-comment">// 画布上元素拖动时步进的为5像素，默认1</span>      drawGrid: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 显示步进点，方便对齐</span>      <span class="hljs-comment">// snapLinks: &#123;</span>      <span class="hljs-comment">//   radius: 5, // 距离元素连接点 5 像素时自动连接上</span>      <span class="hljs-comment">// &#125;,</span>      snapLinks: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 坑注意，3.1 版本设置像素值时会以元素中心点来计算范围</span>      interactive: &#123; <span class="hljs-attr">elementMove</span>: movable, <span class="hljs-attr">labelMove</span>: movable, <span class="hljs-attr">linkMove</span>: movable, <span class="hljs-attr">arrowheadMove</span>: movable &#125;, <span class="hljs-comment">// 禁用元素拖拽、连线标签拖拽</span>      cellViewNamespace: joint.shapes,      <span class="hljs-comment">// linkConnectionPoint: joint.util.shapePerimeterConnectionPoint, // 链接将尝试在连接形状的周长上找到最佳的连接点，而不仅仅是在边界框上（貌似不起作用）</span>    &#125;);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@protected</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>初始化自定义元素</span><span class="hljs-comment">   * 由于元素无法绑定在 joint.shapes 上，所以用 this.customElement 保存自定义元素设置，在导入 graph JSON 时，自定义元素只能手动添加</span><span class="hljs-comment">   */</span>  initCustomElement() &#123;    <span class="hljs-comment">// 此处自定义了一个带有标题头部的矩形元素</span>    <span class="hljs-keyword">this</span>.customElement.HeaderRect = joint.dia.Element.define(<span class="hljs-string">'standard.Header'</span>, &#123;      <span class="hljs-comment">// default attributes</span>      <span class="hljs-comment">// markup 为元素模型参数，tagName 决定 svg 元素类型，selector 为属性选择器名称。整体类似于用 html 标签写的布局框架，后续 attrs 等参数设置相应 svg 标签的属性</span>      markup: [        &#123;          tagName: <span class="hljs-string">'rect'</span>,          selector: <span class="hljs-string">'header'</span>,        &#125;,        &#123;          tagName: <span class="hljs-string">'rect'</span>,          selector: <span class="hljs-string">'body'</span>,        &#125;,        &#123;          tagName: <span class="hljs-string">'text'</span>,          selector: <span class="hljs-string">'headerText'</span>,        &#125;,        &#123;          tagName: <span class="hljs-string">'text'</span>,          selector: <span class="hljs-string">'bodyText'</span>,          children: [            &#123;              tagName: <span class="hljs-string">'tspan'</span>,              selector: <span class="hljs-string">'bodyText1'</span>,            &#125;,            &#123;              tagName: <span class="hljs-string">'tspan'</span>,              selector: <span class="hljs-string">'bodyText2'</span>,            &#125;,          ],        &#125;,      ],      attrs: &#123;        header: &#123;          refWidth: <span class="hljs-string">'100%'</span>, <span class="hljs-comment">// 相对宽度</span>          height: <span class="hljs-number">30</span>, <span class="hljs-comment">// 绝对高度</span>          strokeWidth: <span class="hljs-number">1</span>, <span class="hljs-comment">// 边框宽度</span>          stroke: <span class="hljs-string">'#000000'</span>, <span class="hljs-comment">// 边框颜色</span>          fill: <span class="hljs-string">'#eee'</span>, <span class="hljs-comment">// 背景颜色</span>          fontSize: <span class="hljs-string">'16'</span>, <span class="hljs-comment">// 字体大小</span>        &#125;,        body: &#123;          refWidth: <span class="hljs-string">'100%'</span>,          refHeight: <span class="hljs-string">'70%'</span>, <span class="hljs-comment">// 相对高度</span>          refY: <span class="hljs-number">30</span>, <span class="hljs-comment">// 相对位置</span>          strokeWidth: <span class="hljs-number">1</span>,          stroke: <span class="hljs-string">'#000000'</span>,          fill: <span class="hljs-string">'#fff'</span>,        &#125;,        headerText: &#123;          textVerticalAnchor: <span class="hljs-string">'middle'</span>, <span class="hljs-comment">// 文字垂直对齐</span>          textAnchor: <span class="hljs-string">'middle'</span>, <span class="hljs-comment">// 文字水平对齐</span>          refX: <span class="hljs-string">'50%'</span>,          refY: <span class="hljs-number">15</span>,          fontSize: <span class="hljs-number">16</span>,          fill: <span class="hljs-string">'#000'</span>, <span class="hljs-comment">// 在 tspan, text 标签中，fill 为字体颜色，具体参考 svg 文档</span>        &#125;,        bodyText: &#123;          <span class="hljs-comment">// textAnchor: 'middle',</span>          refX: <span class="hljs-string">'5%'</span>,          refY: <span class="hljs-number">30</span>,          fontSize: <span class="hljs-number">14</span>,          fill: <span class="hljs-string">'#000'</span>,        &#125;,        bodyText1: &#123;          fontSize: <span class="hljs-number">14</span>,          fill: <span class="hljs-string">'red'</span>,        &#125;,        bodyText2: &#123;          fontSize: <span class="hljs-number">14</span>,          fill: <span class="hljs-string">'#000'</span>,        &#125;,      &#125;,    &#125;);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@protected</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>决定需要绑定哪些画布事件，可重写</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;function&#125;</span> </span>callback 仅设置点击事件的回调函数</span><span class="hljs-comment">   */</span>  bindEvent(callback, highlight) &#123;    <span class="hljs-keyword">this</span>.bindMouseWheel();    <span class="hljs-keyword">this</span>.bindDragPaper();    <span class="hljs-keyword">this</span>.bindClick(callback, highlight);    <span class="hljs-keyword">this</span>.bindLinkEvent();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>绑定鼠标滚轮缩放事件</span><span class="hljs-comment">   */</span>  bindMouseWheel() &#123;    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:mousewheel'</span>, (e, x, y, delta) =&gt; <span class="hljs-keyword">this</span>.handleCellMouseWheel(e, x, y, delta));    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'element:mousewheel'</span>, (cellView, e, x, y, delta) =&gt; <span class="hljs-keyword">this</span>.handleCellMouseWheel(e, x, y, delta));  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * 复制代码</span><span class="hljs-comment">   */</span>  handleCellMouseWheel(e, x, y, delta) &#123;    e.preventDefault();    <span class="hljs-keyword">const</span> oldScale = <span class="hljs-keyword">this</span>.paper.scale().sx;    <span class="hljs-keyword">const</span> newScale = oldScale + delta * <span class="hljs-number">0.1</span>;    <span class="hljs-keyword">this</span>.scaleToPoint(newScale, x, y);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * 复制代码</span><span class="hljs-comment">   */</span>  scaleToPoint(nextScale, x, y) &#123;    <span class="hljs-keyword">if</span> (nextScale &gt;= MIN_SCALE &amp;&amp; nextScale &lt;= MAX_SCALE) &#123;      <span class="hljs-keyword">const</span> currentScale = <span class="hljs-keyword">this</span>.paper.scale().sx;      <span class="hljs-keyword">const</span> beta = currentScale / nextScale;      <span class="hljs-keyword">const</span> ax = x - x * beta;      <span class="hljs-keyword">const</span> ay = y - y * beta;      <span class="hljs-keyword">const</span> translate = <span class="hljs-keyword">this</span>.paper.translate();      <span class="hljs-keyword">const</span> nextTx = translate.tx - ax * nextScale;      <span class="hljs-keyword">const</span> nextTy = translate.ty - ay * nextScale;      <span class="hljs-keyword">this</span>.paper.translate(nextTx, nextTy);      <span class="hljs-keyword">const</span> ctm = <span class="hljs-keyword">this</span>.paper.matrix();      ctm.a = nextScale;      ctm.d = nextScale;      <span class="hljs-keyword">this</span>.paper.matrix(ctm);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>绑定画布平移事件，mousedown 记录当前画布位置坐标（并计算缩放比），mouseup 清除当前画布位置坐标</span><span class="hljs-comment">   * 画布本身未定义鼠标移动相关事件，所以利用 dom 监听 mousemove 事件，将鼠标移动参数转换为画布移动</span><span class="hljs-comment">   * 组件卸载时要调用 destroy 事件清除事件监听</span><span class="hljs-comment">   */</span>  bindDragPaper() &#123;    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:pointerdown'</span>, (e, x, y) =&gt; &#123;      <span class="hljs-keyword">const</span> scale = <span class="hljs-keyword">this</span>.paper.scale();      <span class="hljs-keyword">this</span>.dragPosition = [x * scale.sx, y * scale.sy];      <span class="hljs-keyword">this</span>.element.removeEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc);      <span class="hljs-keyword">this</span>.element.addEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc.bind(<span class="hljs-keyword">this</span>));    &#125;);    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:pointerup blank:mouseout'</span>, (e) =&gt; &#123;      <span class="hljs-keyword">this</span>.dragPosition = [];      <span class="hljs-keyword">this</span>.element.removeEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc);    &#125;);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>转换画布平移坐标</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>e mousemove 事件回调对象</span><span class="hljs-comment">   */</span>  dragFunc(e) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dragPosition.length) &#123;      <span class="hljs-keyword">this</span>.paper.translate(e.offsetX - <span class="hljs-keyword">this</span>.dragPosition[<span class="hljs-number">0</span>], e.offsetY - <span class="hljs-keyword">this</span>.dragPosition[<span class="hljs-number">1</span>]);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>绑定元素点击事件</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;function&#125;</span> </span>callback 回调函数</span><span class="hljs-comment">   */</span>  bindClick(callback, highlight) &#123;    <span class="hljs-keyword">const</span> bindFunc = <span class="hljs-function">(<span class="hljs-params">cellView, evt, x, y</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> cells = <span class="hljs-keyword">this</span>.graph.getCells();      cells.forEach(<span class="hljs-function">(<span class="hljs-params">cell</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 取消其他元素高亮</span>        <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">this</span>.paper.findViewByModel(cell);        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> view.unhighlight === <span class="hljs-string">'function'</span>) &#123;          view.unhighlight();        &#125;      &#125;);      <span class="hljs-comment">// 高亮当前点击的元素</span>      <span class="hljs-keyword">if</span> (cellView &amp;&amp; highlight) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cellView.highlight === <span class="hljs-string">'function'</span>) &#123;          cellView.highlight();        &#125;      &#125;      <span class="hljs-comment">// 点击事件回调</span>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) &#123;        callback(cellView);      &#125;    &#125;;    <span class="hljs-comment">// 绑定元素点击事件，坑注意：绑定 pointerclick 会有无法触发的 bug，退而监听 pointerup</span>    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'cell:pointerup link:pointerup'</span>, (cellView, evt, x, y) =&gt; bindFunc(cellView, evt, x, y));    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:pointerup'</span>, (evt, x, y) =&gt; bindFunc(<span class="hljs-literal">null</span>, evt, x, y));  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>绑定连线相关属性，参考官方手册</span><span class="hljs-comment">   */</span>  bindLinkEvent() &#123;    <span class="hljs-comment">// 绑定连线的操作</span>    <span class="hljs-keyword">const</span> verticesTool = <span class="hljs-keyword">new</span> joint.linkTools.Vertices();    <span class="hljs-keyword">const</span> segmentsTool = <span class="hljs-keyword">new</span> joint.linkTools.Segments();    <span class="hljs-keyword">const</span> sourceArrowheadTool = <span class="hljs-keyword">new</span> joint.linkTools.SourceArrowhead();    <span class="hljs-keyword">const</span> targetArrowheadTool = <span class="hljs-keyword">new</span> joint.linkTools.TargetArrowhead();    <span class="hljs-keyword">const</span> sourceAnchorTool = <span class="hljs-keyword">new</span> joint.linkTools.SourceAnchor();    <span class="hljs-keyword">const</span> targetAnchorTool = <span class="hljs-keyword">new</span> joint.linkTools.TargetAnchor();    <span class="hljs-keyword">const</span> boundaryTool = <span class="hljs-keyword">new</span> joint.linkTools.Boundary();    <span class="hljs-keyword">const</span> removeButton = <span class="hljs-keyword">new</span> joint.linkTools.Remove();    <span class="hljs-keyword">const</span> toolsView = <span class="hljs-keyword">new</span> joint.dia.ToolsView(&#123;      tools: [        verticesTool,        segmentsTool,        sourceArrowheadTool,        targetArrowheadTool,        sourceAnchorTool,        targetAnchorTool,        boundaryTool,        removeButton,      ],    &#125;);    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'link:mouseenter'</span>, (linkView) =&gt; &#123;      linkView.addTools(toolsView);      linkView.showTools(toolsView);    &#125;);    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'link:mouseleave'</span>, (linkView) =&gt; &#123;      <span class="hljs-comment">// 坑注意：3.1 版本不能用 addTools 和 removeTools 搭配，不然工具会 bug，显示不全</span>      linkView.hideTools();    &#125;);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>添加圆形</span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span> </span>返回圆形元素的 ID</span><span class="hljs-comment">   */</span>  addCircle(x = <span class="hljs-number">10</span>, y = <span class="hljs-number">10</span>) &#123;    <span class="hljs-keyword">const</span> circle = <span class="hljs-keyword">new</span> joint.shapes.standard.Circle();    circle.resize(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>);    circle.position(x, y);    circle.attr(<span class="hljs-string">'root/title'</span>, <span class="hljs-string">'测站号'</span>); <span class="hljs-comment">// dom 的 title 属性</span>    circle.attr(<span class="hljs-string">'label/text'</span>, <span class="hljs-string">''</span>); <span class="hljs-comment">// 文字</span>    circle.attr(<span class="hljs-string">'label/fontSize'</span>, <span class="hljs-string">'25'</span>); <span class="hljs-comment">// 文字大小</span>    circle.attr(<span class="hljs-string">'body/fill'</span>, <span class="hljs-string">'#f79204'</span>); <span class="hljs-comment">// 背景颜色</span>    circle.attr(<span class="hljs-string">'body/stroke'</span>, <span class="hljs-string">'#f79204'</span>); <span class="hljs-comment">// 边框颜色</span>    circle.attr(<span class="hljs-string">'label/fill'</span>, <span class="hljs-string">'#fff'</span>);    <span class="hljs-keyword">this</span>.graph.addCell(circle);    <span class="hljs-keyword">return</span> circle.id;    <span class="hljs-comment">// joint.util.breakText('this is quite a long text', &#123; width: 50 &#125;) 自动根据宽度换行</span>  &#125;  <span class="hljs-comment">// 自定义元素失败，仅当参考</span>  addParamRect() &#123;    <span class="hljs-keyword">const</span> that = <span class="hljs-keyword">this</span>;    joint.shapes.html = &#123;&#125;;    joint.shapes.html.Element = joint.shapes.basic.Rect.extend(&#123;      defaults: joint.util.deepSupplement(        &#123;          type: <span class="hljs-string">'html.Element'</span>,          attrs: &#123;            rect: &#123; <span class="hljs-attr">stroke</span>: <span class="hljs-string">'none'</span>, <span class="hljs-string">'fill-opacity'</span>: <span class="hljs-number">0</span> &#125;,          &#125;,        &#125;,        joint.shapes.basic.Rect.prototype.defaults      ),    &#125;);    joint.shapes.html.ElementView = joint.dia.ElementView.extend(&#123;      template: [        <span class="hljs-string">'&lt;div class="html-element-rect"&gt;'</span>,        <span class="hljs-string">'&lt;div class="html-element-rect-header"&gt;&lt;/div&gt;'</span>,        <span class="hljs-string">'&lt;div class="html-element-rect-body1"&gt;&lt;/div&gt;'</span>,        <span class="hljs-string">'&lt;div class="html-element-rect-body2"&gt;&lt;/div&gt;'</span>,        <span class="hljs-string">'&lt;div class="html-element-rect-body3"&gt;&lt;/div&gt;'</span>,        <span class="hljs-string">'&lt;/div&gt;'</span>,      ].join(<span class="hljs-string">''</span>),      initialize() &#123;        _.bindAll(<span class="hljs-keyword">this</span>, <span class="hljs-string">'updateBox'</span>);        joint.dia.ElementView.prototype.initialize.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);        <span class="hljs-keyword">this</span>.$box = $(_.template(<span class="hljs-keyword">this</span>.template)());        <span class="hljs-comment">// // This is an example of reacting on the input change and storing the input data in the cell model.</span>        <span class="hljs-comment">// this.$box.find('input').on(</span>        <span class="hljs-comment">//   'change',</span>        <span class="hljs-comment">//   _.bind(function (evt) &#123;</span>        <span class="hljs-comment">//     this.model.set('input', $(evt.target).val());</span>        <span class="hljs-comment">//   &#125;, this)</span>        <span class="hljs-comment">// );</span>        <span class="hljs-comment">// this.$box.find('select').on(</span>        <span class="hljs-comment">//   'change',</span>        <span class="hljs-comment">//   _.bind(function (evt) &#123;</span>        <span class="hljs-comment">//     this.model.set('select', $(evt.target).val());</span>        <span class="hljs-comment">//   &#125;, this)</span>        <span class="hljs-comment">// );</span>        <span class="hljs-comment">// this.$box.find('select').val(this.model.get('select'));</span>        <span class="hljs-comment">// this.$box.find('.delete').on('click', _.bind(this.model.remove, this.model));</span>        <span class="hljs-comment">// // Update the box position whenever the underlying model changes.</span>        <span class="hljs-keyword">this</span>.model.on(<span class="hljs-string">'change'</span>, <span class="hljs-keyword">this</span>.updateBox, <span class="hljs-keyword">this</span>);        <span class="hljs-comment">// Remove the box when the model gets removed from the graph.</span>        <span class="hljs-keyword">this</span>.model.on(<span class="hljs-string">'remove'</span>, <span class="hljs-keyword">this</span>.removeBox, <span class="hljs-keyword">this</span>);        <span class="hljs-keyword">this</span>.updateBox();      &#125;,      render() &#123;        joint.dia.ElementView.prototype.render.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);        <span class="hljs-keyword">this</span>.paper.$el.prepend(<span class="hljs-keyword">this</span>.$box);        <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.paper, <span class="hljs-string">'scale'</span>, <span class="hljs-keyword">this</span>.updateBox);        <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.paper, <span class="hljs-string">'translate'</span>, <span class="hljs-keyword">this</span>.updateBox);        <span class="hljs-keyword">this</span>.updateBox();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125;,      updateBox() &#123;        <span class="hljs-comment">// Set the position and dimension of the box so that it covers the JointJS element.</span>        <span class="hljs-keyword">const</span> bbox = <span class="hljs-keyword">this</span>.model.getBBox();        <span class="hljs-keyword">const</span> scale = that.paper.scale();        <span class="hljs-keyword">const</span> trans = that.paper.translate();        <span class="hljs-comment">// Example of updating the HTML with a data stored in the cell model.</span>        <span class="hljs-keyword">this</span>.$box.find(<span class="hljs-string">'html-element-rect-header'</span>).text(<span class="hljs-keyword">this</span>.model.get(<span class="hljs-string">'header'</span>));        <span class="hljs-keyword">this</span>.$box.find(<span class="hljs-string">'html-element-rect-body1'</span>).text(<span class="hljs-keyword">this</span>.model.get(<span class="hljs-string">'body1'</span>));        <span class="hljs-keyword">this</span>.$box.find(<span class="hljs-string">'html-element-rect-body2'</span>).text(<span class="hljs-keyword">this</span>.model.get(<span class="hljs-string">'body2'</span>));        <span class="hljs-keyword">this</span>.$box.find(<span class="hljs-string">'html-element-rect-body3'</span>).text(<span class="hljs-keyword">this</span>.model.get(<span class="hljs-string">'body3'</span>));        <span class="hljs-keyword">this</span>.$box.css(&#123;          <span class="hljs-comment">// transform: `scale($&#123;scale.sx&#125;,$&#123;scale.sy&#125;)`,</span>          transformOrigin: <span class="hljs-string">'0 0'</span>,          width: bbox.width * scale.sx,          height: bbox.height * scale.sy,          left: bbox.x * scale.sx + trans.tx,          top: bbox.y * scale.sy + trans.ty,        &#125;);      &#125;,      removeBox(evt) &#123;        <span class="hljs-keyword">this</span>.$box.remove();      &#125;,    &#125;);    <span class="hljs-keyword">const</span> el1 = <span class="hljs-keyword">new</span> joint.shapes.html.Element(&#123;      position: &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">80</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">80</span> &#125;,      size: &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">170</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">100</span> &#125;,      header: <span class="hljs-string">'I am HTML'</span>,      body1: <span class="hljs-string">'1111'</span>,      body2: <span class="hljs-string">'2222'</span>,      body3: <span class="hljs-string">'3333'</span>,    &#125;);    <span class="hljs-keyword">this</span>.graph.addCell(el1);    <span class="hljs-keyword">return</span> el1.id;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>添加自定义的标题框，参数均为可选</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>x 坐标</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>y 坐标</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>width 宽度</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>height 高度</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>headerText 标题文字</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>bodyText1 红色预警文字</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>bodyText2 普通文字</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;sting&#125;</span> </span>id 覆盖自身生成的 ID</span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span> </span>返回元素ID</span><span class="hljs-comment">   */</span>  addHeaderRect(x = <span class="hljs-number">100</span>, y = <span class="hljs-number">10</span>, width = <span class="hljs-number">150</span>, height = <span class="hljs-number">100</span>, headerText = <span class="hljs-string">''</span>, bodyText1 = <span class="hljs-string">''</span>, bodyText2 = <span class="hljs-string">''</span>, id = <span class="hljs-string">''</span>) &#123;    <span class="hljs-keyword">const</span> headeredRectangle = <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.customElement.HeaderRect();    headeredRectangle.resize(width, height);    headeredRectangle.position(x, y);    headeredRectangle.attr(<span class="hljs-string">'headerText/text'</span>, headerText);    headeredRectangle.attr(<span class="hljs-string">'bodyText1/text'</span>, bodyText1);    headeredRectangle.attr(<span class="hljs-string">'bodyText2/text'</span>, <span class="hljs-string">`\n<span class="hljs-subst">$&#123;bodyText2&#125;</span>`</span>); <span class="hljs-comment">// svg 控制换行非常麻烦，用 \n 能够解决换行的问题</span>    <span class="hljs-keyword">if</span> (id) &#123;      <span class="hljs-comment">// 回显画布时，覆盖自身生成的 ID</span>      headeredRectangle.prop([<span class="hljs-string">'id'</span>], id);    &#125;    <span class="hljs-keyword">this</span>.graph.addCell(headeredRectangle);    <span class="hljs-keyword">return</span> headeredRectangle.id;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>添加矩形</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>x 初始坐标</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>y 初始坐标</span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span> </span>返回矩形 ID</span><span class="hljs-comment">   */</span>  addRect(x = <span class="hljs-number">50</span>, y = <span class="hljs-number">10</span>) &#123;    <span class="hljs-keyword">const</span> rect = <span class="hljs-keyword">new</span> joint.shapes.standard.Rectangle();    rect.resize(<span class="hljs-number">90</span>, <span class="hljs-number">40</span>);    rect.position(x, y);    rect.attr(<span class="hljs-string">'root/title'</span>, <span class="hljs-string">'joint.shapes.standard.Rectangle'</span>);    rect.attr(<span class="hljs-string">'label/text'</span>, <span class="hljs-string">''</span>);    rect.attr(<span class="hljs-string">'label/fontSize'</span>, <span class="hljs-string">'18'</span>);    rect.attr(<span class="hljs-string">'body/stroke'</span>, <span class="hljs-string">'#6cbd16'</span>);    rect.attr(<span class="hljs-string">'body/fill'</span>, <span class="hljs-string">'#6cbd16'</span>);    rect.attr(<span class="hljs-string">'label/fill'</span>, <span class="hljs-string">'#fff'</span>);    <span class="hljs-keyword">this</span>.graph.addCell(rect);    <span class="hljs-keyword">return</span> rect.id;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>添加连接线</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>x 初始坐标</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>y 初始坐标</span><span class="hljs-comment">   */</span>  addLink(x = <span class="hljs-number">50</span>, y = <span class="hljs-number">50</span>) &#123;    <span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> joint.shapes.standard.Link();    link.source(&#123; x, y &#125;); <span class="hljs-comment">// 起点，可以传元素字符串 ID</span>    link.target(&#123; <span class="hljs-attr">x</span>: x + <span class="hljs-number">80</span>, y &#125;); <span class="hljs-comment">// 终点</span>    link.labels([      &#123;        attrs: &#123;          text: &#123;            text: <span class="hljs-string">''</span>, <span class="hljs-comment">// 标签文字</span>          &#125;,        &#125;,      &#125;,    ]);    link.attr(<span class="hljs-string">'line/stroke'</span>, <span class="hljs-string">'#2f76ff'</span>); <span class="hljs-comment">// 线条颜色</span>    link.prop([<span class="hljs-string">'doubleLinkTools'</span>], <span class="hljs-string">'true'</span>); <span class="hljs-comment">// 显示双箭头</span>    link.prop([<span class="hljs-string">'labels'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'attrs'</span>, <span class="hljs-string">'rect'</span>, <span class="hljs-string">'fill'</span>], <span class="hljs-string">'rgba(0, 0, 0, 0)'</span>); <span class="hljs-comment">// 标签背景矩形颜色</span>    <span class="hljs-keyword">this</span>.graph.addCell(link);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>移除单个元素</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>cellView 元素对象，视图对象或者模型对象均可</span><span class="hljs-comment">   */</span>  removeItem(cellView) &#123;    <span class="hljs-keyword">if</span> (cellView.model &amp;&amp; <span class="hljs-keyword">typeof</span> cellView.model.remove === <span class="hljs-string">'function'</span>) &#123;      cellView.model.remove();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cellView.remove === <span class="hljs-string">'function'</span>) &#123;      cellView.remove();    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>获取当前画布所有元素</span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Array&#125;</span> </span>元素数组</span><span class="hljs-comment">   */</span>  getCells() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.graph.getCells();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>用元素 ID 获取元素视图对象</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">id</span></span></span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> </span>元素视图对象</span><span class="hljs-comment">   */</span>  getCellByID(id) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.graph.getCell(id);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>获取画布当前的缩放比例和平移位置</span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> <span class="hljs-type">&#123;scale, position&#125;</span></span></span><span class="hljs-comment">   */</span>  getPaperScaleAndPos() &#123;    <span class="hljs-keyword">const</span> scale = <span class="hljs-keyword">this</span>.paper.scale();    <span class="hljs-keyword">const</span> position = <span class="hljs-keyword">this</span>.paper.translate();    <span class="hljs-keyword">return</span> &#123; scale, position &#125;;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>清除当前画布</span><span class="hljs-comment">   */</span>  clearGraph() &#123;    <span class="hljs-keyword">this</span>.graph.clear();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>销毁当前画布，并且销毁画布所有监听事件</span><span class="hljs-comment">   */</span>  destroy() &#123;    <span class="hljs-keyword">this</span>.clearGraph();    <span class="hljs-keyword">this</span>.paper.remove();    <span class="hljs-keyword">this</span>.element.removeEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>导出画布元素</span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> <span class="hljs-variable">JSON</span></span></span><span class="hljs-comment">   */</span>  exportGraph() &#123;    <span class="hljs-keyword">const</span> jsonData = <span class="hljs-keyword">this</span>.graph.toJSON();    <span class="hljs-keyword">return</span> jsonData;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>导入画布数据，JSON 对象，非 JSON 字符串</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>jsonData JSON</span><span class="hljs-comment">   * <span class="hljs-doctag">@example <span class="hljs-type">&#123;"cells": [&#123;...&#125;</span></span>, &#123;...&#125;]&#125;</span><span class="hljs-comment">   */</span>  importGraph(jsonData) &#123;    <span class="hljs-keyword">this</span>.graph.fromJSON(jsonData);  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> JointJS;</code></pre>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在 koa2 上使用 swagger 自动生成接口文档</title>
    <link href="/2020/12/07/20200819/"/>
    <url>/2020/12/07/20200819/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/83760346_p0.png" srcset="/img/loading.gif" alt=""></p><h1 id="在-koa2-上使用-swagger-自动生成接口文档"><a href="#在-koa2-上使用-swagger-自动生成接口文档" class="headerlink" title="在 koa2 上使用 swagger 自动生成接口文档"></a>在 koa2 上使用 swagger 自动生成接口文档</h1><!-- TOC --><ul><li><a href="#在-koa2-上使用-swagger-自动生成接口文档">在 koa2 上使用 swagger 自动生成接口文档</a><ul><li><a href="#11-配置步骤">1.1. 配置步骤</a><ul><li><a href="#111-安装">1.1.1. 安装</a></li><li><a href="#112-配置-swagger-jsdoc">1.1.2. 配置 swagger-jsdoc</a></li><li><a href="#113-配置-koa2--swagger-ui">1.1.3. 配置 koa2–swagger-ui</a></li></ul></li><li><a href="#12-文档使用">1.2. 文档使用</a></li></ul></li></ul><!-- /TOC --><hr><p>swagger 官网介绍 <a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></p><p>在 koa2 中要想方便快捷使用 swagger，需要安装两个插件</p><ul><li><p>swagger-jsdoc：<a href="https://github.com/Surnet/swagger-jsdoc" target="_blank" rel="noopener">https://github.com/Surnet/swagger-jsdoc</a></p></li><li><p>koa2-swagger-ui：<a href="https://www.npmjs.com/package/koa2-swagger-ui" target="_blank" rel="noopener">https://www.npmjs.com/package/koa2-swagger-ui</a></p></li></ul><p>其实这两个插件并没有依赖关系，前者 swagger-jsdoc 的作用是通过手动添加的路由注释生成 json 文档，而后者 koa2-swagger-ui 则基于生成的 json 文档提供强大的交互阅读界面</p><h2 id="1-1-配置步骤"><a href="#1-1-配置步骤" class="headerlink" title="1.1. 配置步骤"></a>1.1. 配置步骤</h2><h3 id="1-1-1-安装"><a href="#1-1-1-安装" class="headerlink" title="1.1.1. 安装"></a>1.1.1. 安装</h3><blockquote><p>npm i -D swagger-jsdoc koa2-swagger-ui</p></blockquote><h3 id="1-1-2-配置-swagger-jsdoc"><a href="#1-1-2-配置-swagger-jsdoc" class="headerlink" title="1.1.2. 配置 swagger-jsdoc"></a>1.1.2. 配置 swagger-jsdoc</h3><ol><li>首先在项目根目录下新建 <code>swagger.conf.js</code>，示例</li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> swaggerJSDoc = <span class="hljs-built_in">require</span>(<span class="hljs-string">"swagger-jsdoc"</span>);<span class="hljs-keyword">const</span> swaggerDefinition = &#123;  info: &#123;    <span class="hljs-comment">// 自定义文档信息</span>    title: <span class="hljs-string">"gallery"</span>,    version: <span class="hljs-string">"1.0.0"</span>,    description: <span class="hljs-string">"gallery 网站后台 koa api"</span>,  &#125;,  host: <span class="hljs-string">`localhost:3000`</span>, <span class="hljs-comment">// 指定项目地址，建议在环境参数中配置，然后用 process.env 读取</span>  basePath: <span class="hljs-string">"/"</span>,&#125;;<span class="hljs-keyword">const</span> options = &#123;  swaggerDefinition,  apis: [<span class="hljs-string">"./app/routes/*.js"</span>], <span class="hljs-comment">// 指定项目路由的相对路径，相对于 basePath</span>&#125;;<span class="hljs-keyword">const</span> swaggerSpec = swaggerJSDoc(options);<span class="hljs-built_in">module</span>.exports = swaggerSpec;</code></pre><ol><li>在上述配置文件中导出 swaggerSpec 后，新建一个路由 <code>docs.js</code>，返回该配置文件（其实就是指向了 swagger-jsdoc 生成的 json 文档），<strong>此路由返回的文档正是 koa2–swagger-ui 所需的 json 文档</strong></li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> Router = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa-router"</span>);<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router();<span class="hljs-keyword">const</span> swaggerSpec = <span class="hljs-built_in">require</span>(<span class="hljs-string">"../../swagger.conf"</span>); <span class="hljs-comment">// 注意文件路径</span><span class="hljs-comment">// 注意 url 地址，可自定义，在 koa2--swagger-ui 配置中需要引用</span>router.get(<span class="hljs-string">"/swaggerDoc"</span>, <span class="hljs-keyword">async</span> (ctx) =&gt; &#123;  ctx.body = swaggerSpec;&#125;);<span class="hljs-built_in">module</span>.exports = router;</code></pre><h3 id="1-1-3-配置-koa2–swagger-ui"><a href="#1-1-3-配置-koa2–swagger-ui" class="headerlink" title="1.1.3. 配置 koa2–swagger-ui"></a>1.1.3. 配置 koa2–swagger-ui</h3><ol><li>在项目入口文件中配置 koa2–swagger-ui，示例</li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa"</span>);<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<span class="hljs-keyword">const</span> swagger = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa2-swagger-ui"</span>);<span class="hljs-keyword">const</span> routing = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./routes"</span>);<span class="hljs-comment">// 开启 swagger 静态服务</span>app.use(  swagger(&#123;    routePrefix: <span class="hljs-string">"/docs"</span>, <span class="hljs-comment">// 自定义 koa2-swagger-ui 生成的交互界面 url</span>    swaggerOptions: &#123;      <span class="hljs-comment">// 重要选项！url地址一定要指向为 swagger-jsdoc 配置的路由地址</span>      url: <span class="hljs-string">"http://localhost:3000/swaggerDoc"</span>,    &#125;,  &#125;));<span class="hljs-comment">// 路由绑定请自行实现</span>routing(app);app.listen(<span class="hljs-number">3000</span>, () =&gt; &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"App running at 3000 port"</span>);&#125;);</code></pre><h2 id="1-2-文档使用"><a href="#1-2-文档使用" class="headerlink" title="1.2. 文档使用"></a>1.2. 文档使用</h2><p>至此，swagger 的配置就已经全部完成，访问 <code>http://localhost:3000/docs</code> 即可查看 swagger-ui 提供的强大操作界面，接下来只要为各个路由加上注释即可，路由注释规范可参考官网示例 <a href="https://github.com/Surnet/swagger-jsdoc/blob/master/example/v2/routes.js" target="_blank" rel="noopener">https://github.com/Surnet/swagger-jsdoc/blob/master/example/v2/routes.js</a></p>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次星轨拍摄</title>
    <link href="/2020/08/16/20200816/"/>
    <url>/2020/08/16/20200816/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/star.png" srcset="/img/loading.gif" alt=""></p><p>本来打算12号回老家拍英仙座流星雨，结果天公不作美，天气太差了，13号才回去，然而13号天气也不算太好</p><p>经过两三个小时和蚊子斗智斗勇，拍了300来张照片之后，发现几乎就没拍到流星，只有两三颗而且特别暗，太失望了。。最后只能拿一组照片做星轨了</p><p>不过因为老家后面火车还挺多的，多少也给照片添了一些亮点，真·亮点ww</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>又是怀疑人生的一天</title>
    <link href="/2020/06/21/20200621/"/>
    <url>/2020/06/21/20200621/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/82374429_p0.jpg" srcset="/img/loading.gif" alt=""></p><p>——<em>人活着本来就没什么意义，又何必自己折磨自己</em></p><p>终于推完了 ATRI，故事很棒，结局也挺好，可是加上最近的烦心事，让我感觉更加怀疑人生了。</p><p>并不是我对未来有什么偏见，但是我真的觉得未来不值得我期待了，是因为还没摆脱心中那份孤独感吗。。我不明白。</p><p>明天老姐过生日了，也就是说，我的生日也快到了，不知道能不能在生日那天之前解脱，回家好好过生日呢。。希望如此吧。</p><p>为什么我会对他们抱着如此憎恨的心情呢，其实大家并不是多么坏的人，可能多少有点自私吧，但是谁又不是一样呢，我在别人眼中也不见得是多么正直的一个人吧。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最近遇到的一些坑</title>
    <link href="/2020/06/07/20200607/"/>
    <url>/2020/06/07/20200607/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/2020-06-07.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="最近几天写-React、配置内网穿透遇到一些坑，记录一下。"><a href="#最近几天写-React、配置内网穿透遇到一些坑，记录一下。" class="headerlink" title="最近几天写 React、配置内网穿透遇到一些坑，记录一下。"></a>最近几天写 React、配置内网穿透遇到一些坑，记录一下。</h3><hr><h2 id="nginx-proxy-pass-路径解析"><a href="#nginx-proxy-pass-路径解析" class="headerlink" title="nginx proxy_pass 路径解析"></a>nginx proxy_pass 路径解析</h2><blockquote><p>在 <code>location</code> 块中，路径最后有无 <code>/</code> 号对解析结果影响很大，例如：</p></blockquote><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> /api/ &#123;    <span class="hljs-attribute">proxy_pass</span> http://kanata.moe/;&#125;<span class="hljs-attribute">location</span> /api/ &#123;    <span class="hljs-attribute">proxy_pass</span> http://kanata.moe;&#125;</code></pre><p>这两种方式的解析结果是不一样的</p><ul><li>第一种方式，访问 <code>/api</code> 时，解析结果为 <a href="http://kanata.moe/" target="_blank" rel="noopener">http://kanata.moe/</a></li><li>第二种方式，访问 <code>/api</code> 时，解析结果为 <a href="http://kanata.moe/api" target="_blank" rel="noopener">http://kanata.moe/api</a></li></ul><hr><h2 id="koa2-组件-koa-body-与-koa-bodyParser-的冲突"><a href="#koa2-组件-koa-body-与-koa-bodyParser-的冲突" class="headerlink" title="koa2 组件 koa-body 与 koa-bodyParser 的冲突"></a>koa2 组件 koa-body 与 koa-bodyParser 的冲突</h2><p><code>koa-body</code> 组件能够处理文件上传和参数传递，而 <code>koa-bodyParser</code> 只能处理参数</p><blockquote><p>两个组件不能同时使用，否则 koa 可能不报错，但一直无响应</p></blockquote><h3 id="艰难的调试过程"><a href="#艰难的调试过程" class="headerlink" title="艰难的调试过程"></a>艰难的调试过程</h3><ol><li>前端 React 发出 ajax POST 上传文件请求，后端返回 504 响应超时</li><li>前端 Postman 模拟 POST 带参数请求，后端返回 200 处理成功</li><li>前端确认 React 中 ajax 请求代码无误</li><li>检查 nginx 代理设置与跨域设置，添加跨域选项（前后端并未发生跨域请求，删除跨域选项）</li><li>检查 koa2 路由设置正常，log 无报错，使用 console.log() 发现请求并未到达路由</li><li>检查 koa2 接收的访问参数、访问地址正常</li><li>用 console.log() 逐级排查 koa2 洋葱模型</li><li>定位到 core/init.js 中对 koa-body 和 koa-bodyParser 的引用</li><li>尝试删除对 koa-bodyParser 的引用，bug 修复成功</li></ol><hr><h2 id="MySQL-触发器的编写"><a href="#MySQL-触发器的编写" class="headerlink" title="MySQL 触发器的编写"></a>MySQL 触发器的编写</h2><p>MySQL 触发器是个非常方便的功能，能够快速实现数据表之间的数据关联，例：</p><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> setu;<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> count_score;<span class="hljs-comment"># 将结束符号替换为 $$</span>DELIMITER $$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> count_score <span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> scores <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span><span class="hljs-keyword">BEGIN</span>    <span class="hljs-comment"># 不能直接对 DECLARE 的变量赋值</span>    <span class="hljs-keyword">DECLARE</span> newScore <span class="hljs-built_in">INT</span>;    <span class="hljs-comment"># 使用 INTO 将 SELECT 结果赋值给变量</span>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">AVG</span>(score)) <span class="hljs-keyword">INTO</span> newScore <span class="hljs-keyword">FROM</span> scores <span class="hljs-keyword">WHERE</span> scores.picture_id = NEW.picture_id;    <span class="hljs-keyword">UPDATE</span> pictures <span class="hljs-keyword">SET</span> total_score = newScore <span class="hljs-keyword">WHERE</span> pictures.picture_id = NEW.picture_id;<span class="hljs-keyword">END</span>$$<span class="hljs-comment"># 将结束符号还原为 ;</span>DELIMITER ;</code></pre><p>其中，<code>NEW</code> 指即将插入或已经插入的行，<code>OLD</code> 指即将删除或已经删除的行</p><p>数学计算函数分别有：</p><p><code>AVG() 求平均值</code><br><code>ROUND() 四舍五入取整</code><br><code>CEILING() 向上取整</code><br><code>FLOOR() 向下取整</code></p><hr><h2 id="Let’s-encrypt-泛域名证书的申请"><a href="#Let’s-encrypt-泛域名证书的申请" class="headerlink" title="Let’s encrypt 泛域名证书的申请"></a>Let’s encrypt 泛域名证书的申请</h2><p>其实用 certbot 非常简单，首先安装 certbot，然后执行一条命令：</p><blockquote><p><code>sudo certbot certonly --preferred-challenges dns --manual -d kanata.moe -d *.kanata.moe</code></p></blockquote><ul><li><code>certonly</code> 仅生成证书</li><li><code>--preferred-challenges dns</code> 选择验证方式为 dns</li><li><code>--manual</code> 手动模式</li><li><code>-d</code> 泛域名可以用 * 号，但主域名也必须同时作为参数</li></ul><p>验证过程中，会要求在 dns 解析记录里添加一条 txt 解析<br>然后在 nginx 配置中引入证书路径即可，如：</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-comment"># ...</span>    <span class="hljs-attribute">ssl_certificate</span> /etc/letsencrypt/live/kanata.moe/fullchain.pem;    <span class="hljs-attribute">ssl_certificate_key</span> /etc/letsencrypt/live/kanata.moe/privkey.pem;    <span class="hljs-comment"># ...</span>&#125;</code></pre><p><strong>注意：</strong> 修改与 SSL 相关的配置后，建议<strong>重启</strong> nginx 而不是使用 <code>nginx -s reload</code><br>可以使用 <code>sudo systemctl restart nginx</code> 等</p>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>心情逐渐平静</title>
    <link href="/2020/03/22/20200322/"/>
    <url>/2020/03/22/20200322/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/ETo-J4UU8AIpPj5.jpg" srcset="/img/loading.gif" alt=""></p><p>NAGA 作品，和白羽好像 w</p><p>也算是纠结了一段时间了，最近心情逐渐平静下来了，冷静考虑之后发现，生活其实也就这样，所谓人生也不过如此吧。所以现在也不会经常钻牛角尖了，平平淡淡也挺好的，追求太多只会被现实压垮而已。认真学学写代码，偶尔玩玩游戏，没事做做番，这样也挺好，还有什么好追求的呢。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么会这么迷茫</title>
    <link href="/2020/03/10/20200310/"/>
    <url>/2020/03/10/20200310/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/ESWIAJfUYAI8ce-.png" srcset="/img/loading.gif" alt=""></p><p>五年挣扎终于看到了尽头，为什么反而更加迷茫了，简直就像失去了一切目标，弄丢了对这世界的好奇心。啊啊，原来我根本就不知道我自己究竟想要什么，只是一味地讨厌现在这种生活而已啊。</p><p>我所做的选择是一种自私吗，应该是吧，毕竟大家都说我这样做太蠢了，丝毫不顾及家人的感受，丝毫不考虑结婚生子以后的生活。可是我真的不打算结婚啊。</p><p>唯一让我担心的，就是这挥之不去的孤独感吧，可这又何妨，至少我还活着。我觉得我可能已经变得扭曲不堪了，而我却总是纵容着自己，回过头才发现，原来我依旧身处海南那片深深的绝望之中。</p><p>可是我也不想就这么结束啊，说不定明天会变得比今天好一点点呢，哪怕只是一点点。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>烦恼总是接连不断</title>
    <link href="/2020/02/26/20200226/"/>
    <url>/2020/02/26/20200226/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/ERmYjQIUEAIc5lW.png" srcset="/img/loading.gif" alt=""></p><p>今年二月还有 29 号</p><p>该为找工作发愁了。。之前觉得 PHP 的水平找工作应该不难，现在看来简直太天真了，根本就啥也不懂 ww</p><p>但是要不要转学前端呢，前端要补的东西还有很多，虽然 PHP 也要补但是基础比前端还是好一点。长远来看的话，PHP 竞争力肯定不如前端，但是 PHP 可以转后端架构，甚至转大数据。当然首先问题是能不能找到工作吧 ww</p><p>还是得先把网站项目做完，多学点东西再说吧</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>终于，只剩最后一点时间了</title>
    <link href="/2020/01/18/20200118/"/>
    <url>/2020/01/18/20200118/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_1194.jpg" srcset="/img/loading.gif" alt=""></p><p>私、何を…</p><p>当然，是从乐观的角度来说，再熬过半年就结束了，终于终于要结束了</p><p>长达 5 年的煎熬，虽然也不乏开心的事情，但也永远忘不了被逼入绝境的心情，现在终于看见曙光了，终于快走到终点了。</p><p>以后的事情谁也无法预料，生活这么艰难，谁又过得容易呢，而我也不过是想过得稍微开心一点点而已。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>每次想写点东西的时候，都是心情不好的时候</title>
    <link href="/2019/12/15/20191215/"/>
    <url>/2019/12/15/20191215/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_1149.jpg" srcset="/img/loading.gif" alt=""></p><p>或者说每次心情不好的时候都想写点东西？</p><p>还是算了 w</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>住了一次医院，第一次觉得我开始活得像个普通人了</title>
    <link href="/2019/11/22/20191122/"/>
    <url>/2019/11/22/20191122/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/80965165_p0.jpg" srcset="/img/loading.gif" alt=""></p><p>虽然办了住院手续，不过也就是打针做检查的时候来医院，该上班还是要上班。第一次体会到了被重重现实压迫的无奈感。。明明往返医院已经很心累了，还要在单位疯狂受气。</p><p>这些肯定都是作为普通人需要面对的现实吧，以后工作了说不定还会有更离谱的事情，说不定离家远住院也没人照顾，动手术也只能自己一个人。但是这样也好，这样也是活着啊。</p><p>虽然一堆活没干完，但是休假批了，那就工作去他妈的，安排好住院啊考试啊之类的事情，然后好好休息吧~</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>销毁了高中毕业以来的日记</title>
    <link href="/2019/11/11/20191111/"/>
    <url>/2019/11/11/20191111/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0925.jpg" srcset="/img/loading.gif" alt=""></p><p>8 年多了，日记虽然只写了 3 本，而且几乎都是些负面情绪，不过我还是决定全部扔进了碎纸机，一是保存不方便了，二是，该改改自己念旧的毛病了。</p><p>时间好漫长啊，真想现在就立马办完复员手续，一走了之。但是时间又过得好快啊，想想高中已经毕业 8 年多了，然而我还是任性不懂事。我也搞不懂我自己了 w</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>国庆节也过完啦</title>
    <link href="/2019/10/06/20191006/"/>
    <url>/2019/10/06/20191006/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/B15A9E56A90DD965BCD5BCBC9C6DF509.png" srcset="/img/loading.gif" alt=""></p><p>虽然国庆节也才三四天假，但是也算是扎扎实实玩了几天，玩过之后就忧郁了。。没有目标的感觉真难受，又迷茫又孤独。。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最后的一年</title>
    <link href="/2019/08/24/20190824/"/>
    <url>/2019/08/24/20190824/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0521.jpg" srcset="/img/loading.gif" alt=""></p><p>恍恍惚惚，已经快到 9 月份了，4 年多了终于等来了应有的结果，明年终于可以摆脱组织的束缚，成为一个真正意义上的社会人了。</p><p>算上剩下的这一年，毕业正好 5 年，却也应验了当初说 5 年就可以回来的话，真是讽刺。5 年时间经历了太多，想到明年就要自己出去找工作了，反而有点不适应，也有点不安。</p><p>不过现在还没到放松的时候，最难的首先还是要熬过这一年吧，然后还要面临人生第一次找工作，不知道会碰壁多少次 ww。可是每次面临现在这些乱七八糟的工作内容，还是会觉得很烦人，又不得不好好完成，无奈也没办法，总之也就最后这一年了，再怎么折腾也就一年了，随它去吧。</p><p>好好睡一觉吧，明天也会是忙碌的一天，加班还有一年呢，趁着这一年，把想考的 JLPT、想学的画画、想做的 PHP，一个不落全都完成吧，毕竟，活着本来就没什么意义，还是不能太悲观对吧~</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>哇啊啊啊啊</title>
    <link href="/2019/08/07/20190807/"/>
    <url>/2019/08/07/20190807/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0641.jpg" srcset="/img/loading.gif" alt=""></p><p>想说点开心的事情，但是想来想去好像也没什么开心的事情。。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>追番list</title>
    <link href="/2019/07/15/20190715/"/>
    <url>/2019/07/15/20190715/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0597.jpg" srcset="/img/loading.gif" alt=""></p><p>平凡职业，cop craft，astra，女高日常，街角魔族，重来魔王，ct，jojo，fsn 第二部剧场(待续</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>原来家庭才是最大的困扰</title>
    <link href="/2019/06/15/20190615/"/>
    <url>/2019/06/15/20190615/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0492.jpg" srcset="/img/loading.gif" alt=""></p><p>老妈住院了，说要准备做结石手术，幸好老妹有空先回家了，还能照顾一下，我只能周一请假回去了。</p><p>突然觉得生活其实真的没有那么美好，现实总有压过梦想的时候，又不能随便抛弃这些牵绊，久而久之就会成为影响人生最大的困扰。而我呢？有时候太固执了，一心只想往前冲，可能甩掉了太多重要的东西了吧。不过这条路我还是会继续走下去，谁又知道明天世界会变成什么样子呢。</p><p>即便如此我也不想就此丢掉追逐美好的权利，加把劲~</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[预告]索尼A7+三阳35/2.8和A6000套机实用对比</title>
    <link href="/2019/06/10/20190610/"/>
    <url>/2019/06/10/20190610/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/EX_HPOnUYAYxlLE.jpg" srcset="/img/loading.gif" alt=""></p><p>终于，两台索法的入门级微单都回来了，其实很早就想写篇个人的使用感想了，等这段时间有空了就详细写一写吧。</p><p>其实个人喜欢 A7 多一点，尽管这两台入门辣鸡都属于优缺分明的机型，但是日常使用还是完全没问题的，敬请期待~</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>那么现在我该保持怎样的心态呢</title>
    <link href="/2019/06/04/20190604/"/>
    <url>/2019/06/04/20190604/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0455.jpg" srcset="/img/loading.gif" alt=""></p><p>夏天到啦~</p><p>天气越来越热，心情也跟着烦闷起来了，除了画画课和字幕组的活，代码已经很久没碰了，相机也基本处于吃灰状态，时间不够用（那还打什么游戏）。好想吃冰西瓜~</p><p>虽然按照予定计划，九月份左右就可以筹划罢工跑路了，不过唯一的不确定因素——跑路的代价，还没办法确定。那么在那之前，我该保持怎样的心态呢。或者说是否还有其他的解决方法？</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记第一次服务器被暴力破解攻击</title>
    <link href="/2019/04/29/20190429/"/>
    <url>/2019/04/29/20190429/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0324.png" srcset="/img/loading.gif" alt=""></p><p>很久没维护过服务器了（大概一个月），今天 ssh 连上去看了一下，无意间发现 auth.log 的 fail 记录有点奇怪，重复查看之后发现服务器的 ssh 正在被暴力破解。。。来自好几个不同的 ip ，不过幸好只是单个 ip 的简单攻击，毫不犹豫直接加上了 fail2ban ，端口就懒得改了，ban 了 3 个 ip 之后清净了。。。有点吓人 ww，，以后还是得多注意服务器的安全问题了。。。</p>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>听说又有滚蛋的机会来了</title>
    <link href="/2019/04/22/20190422/"/>
    <url>/2019/04/22/20190422/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0370.png" srcset="/img/loading.gif" alt=""></p><p>本来年底抓住机会回来，就是为了等这个最终机会，现在似乎是脱离这个深坑最后的希望了。。明明都到了这时候，反而有点犹豫了。。虽然风险依然有，但是这是最后的机会了啊</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>每天都是上班下班....</title>
    <link href="/2019/04/03/20190403/"/>
    <url>/2019/04/03/20190403/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0309.jpg" srcset="/img/loading.gif" alt=""></p><p>已经有点感觉不到时间的流动了,,,上班下班一天过去了,,,上班下班一个星期过去了…..也没干啥活但是就是忙,,没办法,,暂时只能这样了吧,,唉</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>四畳半神話大系</title>
    <link href="/2019/03/02/20190302/"/>
    <url>/2019/03/02/20190302/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0221.png" srcset="/img/loading.gif" alt=""></p><p>首先，这部作品有点电波。。魔性的画风和前期重复的剧情和超高速的 CV 旁白有点劝退，,但是，最后的两集一下把所有的剧情全都连接起来，把所有想表达的感情全都连接起来，，瞬间把前期所有的疑惑都解开了，男主被困的时候，，仿佛被困的就是我自己，，就在那一秒之间，，我突然哭了，眼泪大颗大颗根本止不住。。（要不是我妈快下班回家，我能哭一整晚）</p><p>无尽的四畳半房间，无数的平行世界，就像我曾经身处的深渊，和无论怎么努力都逃不脱的命运。我也曾像男主一样，在那四畳半的房间，疯狂渴望着实现一般人根本不放在眼里的小小愿望， 疯狂渴望着，只要能逃出这命运的深渊我什么都愿意干。。。。</p><p>当男主从房间里逃出来的时候，我也回想起，两个月前，那种获得解放的愉悦感，绝非只言片语所能描绘，一花一草都会让我觉得，我还活着真是太好了。。。虽然那之后的我，也经常会迷茫不知所措，但是，，我所得到的，应该就是比一般人更能理解男主的心情吧~~</p><p>语无伦次了，，总之，，这是一部不容错过的好作品，感谢~~</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VS code 插件</title>
    <link href="/2019/02/25/20190225/"/>
    <url>/2019/02/25/20190225/</url>
    
    <content type="html"><![CDATA[<p>auto close tag 自动关闭 html 标签</p><p>auto rename tag 自动更改 html 对应的标签</p><p>debugger for chrome 前端利用 chrome 断点调试</p><p>open in browser 右键浏览器打开文件</p><p>PHP debug 断点调试 PHP</p>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>报了个画画的网络班</title>
    <link href="/2019/02/22/20190222/"/>
    <url>/2019/02/22/20190222/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0238.jpg" srcset="/img/loading.gif" alt=""></p><p>ごと P 的画风非常治愈~~</p><p>也不知道该说是蓄谋已久,,还是一时头脑发热,,反正就是花了一笔不小的钱报了个班….虽然自己自学画了好几年了,,总是看不到进步也的确有点糟心…..(其实就是自己懒</p><p>不管怎么样,,画画肯定会成为之后生活的一部分了,,就算是有时候可能会很忙,,至少也有个缓解压力的方法吧</p><p>说个鸡掰哟,,妈蛋现在想做的事情太多了根本忙不过来了啊!!!!!….VPS 基本上已经成了个 SS 服务器了根本没时间更新网站…..但是不管怎么说,,不让自己闲下来终归是对的,,既然还有想去做的事情,,那就不遗余力的去完成,,,,以此来弥补那被狗吃掉的青春吧 2333</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>新年的一点牢骚</title>
    <link href="/2019/02/06/20190206/"/>
    <url>/2019/02/06/20190206/</url>
    
    <content type="html"><![CDATA[<p>终于闲下心来可以写点东西了，经历了坎坷的本命年之后，现在的心情也是十分复杂。。</p><p>去年上半年可以说是我人生中最黑暗的一段时间了，压抑，暴躁，毫无理性，钻进死胡同出不来，精神接近崩溃，眼看着另一个朋友因为精神崩溃住进了特殊医院，庆幸我在掉下悬崖之前找回了自己，7 月份之后，我过得也还算一般。</p><p>然而就在我以为毫无希望可言的时候，12 月份我却从海南回来了，一点实感都没有，恍惚之间就这么过了一个多月。。在那之前，我日夜幻想着，当这一天到来的时候我会多么高兴多么开心。没想到世界线会以这样的方式收束，措手不及，来不及多想。。</p><p>我以为这就结束了，我一辈子的生活应该就这么被定格了，我也几乎快认命了。“待遇这么好，工作又稳定，我们都羡慕死你了”。这是我所有朋友的一致反应，包括我的家人，无一例外，仿佛这就是所有人一辈子最终的追求。</p><p>但是最近我开始反省，到底什么才是正确的，我所追求的到底是什么。。大学毕业已经有三年多了，我从泥沼之中痛苦挣扎，终于找到了自己的目标，现在的我却慢慢的失去了我曾经坚定不移的东西，曾经为之拼命的东西。。</p><p>这个岔路口可能对我而言没有选择的权利，但是这个岔路口直接决定我的命运，我很迷茫，但是如果真的能让我选择，我觉得我还是应该去拼一次，为了自己真正的梦想，为了自己定义的幸福，也为了不留下这个遗憾。</p><p>2019 年，希望我的幸运还没用完，希望我的血汗不会被白费，加油～</p><p><img src="/img/post/IMG_0139.jpg" srcset="/img/loading.gif" alt=""></p><p>你妈的为什么图倒了(</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>新年快乐！~~</title>
    <link href="/2019/02/04/20190204/"/>
    <url>/2019/02/04/20190204/</url>
    
    <content type="html"><![CDATA[<p>有时间再写点东西，，新年先快乐一下吧ww</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>头痛</title>
    <link href="/2019/01/25/20190125/"/>
    <url>/2019/01/25/20190125/</url>
    
    <content type="html"><![CDATA[<p>简直比三年前那时候还要更迷茫，想着一些不着边际的东西。。</p><p><img src="/img/post/IMG_0005.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于这坑爹的 linux 版网易云。。</title>
    <link href="/2019/01/23/20190123/"/>
    <url>/2019/01/23/20190123/</url>
    
    <content type="html"><![CDATA[<p>安装完之后打不开，，结果搜到的玄学方法是双击加载的时候，，右上打开关机选项，然后再关闭，，，，然后网易云界面就出来了。。奇葩了。。。</p><p><img src="/img/post/81062782_p0.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
